## 18. Java中的异常体系

**Java**的所有异常父类**Throwable**

**Throwable**有两个子类: **Exception**和**Error**

**Error**是错误,一旦出现,程序会自动停止

**Exception**的子类分类: **RunTimeException**和**CheckedException**

检测异常一般不会出现,**会导致编译过程中,编译不通过**

运行时异常在程序执行过程中,**一般导致线程执行失败**



## 19. GC如何判断垃圾回收

首先垃圾回收有**两种算法**:

- **引用计数法**: 如果这个对象**被其他对象所引用**,那么**引用计数加一**,**释放引用**的时候**引用减一**,如果**计数为0**,则代表此对象可以被**回收**

  > [!Tip]
  >
  > 如果A对象引用B对象,A对象引用计数加一,同时B对象应用A对象,B对象的计数加一,就会出现A对象和B对象都无法被回收的场面

- **可达性分析算法**: 有一个**GC Root**,当一个对象到**GC Root**没有引用链的时候,代表该对象可以被回收,Java的GC就是采用这种垃圾回收算法

  相关文章 :[GC Roots 是什么？哪些对象可以作为 GC Root？](https://blog.csdn.net/weixin_38007185/article/details/108093716)

  **GC Root**大概有一下4种类型

  1. 本地方法栈中**Native方法**引用的对象
  2. **虚拟机栈中**引用的对象
  3. 方法区**类静态属性**引用的对象
  4. 方法区中**常量**引用的对象

  <br>被**GC Root**不被引用的对象不一定一定要被回收: **GC Root**给了对象一次存活的机会

  第一次进行可达性分析的时候,对象会被标记

  第二次的时候,看对象是否覆盖了**finalize()**方法,如果没有覆盖,则直接回收,如果覆盖了,就会执行**finalize()方法**,然后再进行可达性分析



## 20. 线程的生命周期,线程的几种状态

线程的5种状态: **创建,就绪,运行,阻塞,死亡**

1. **创建**: 新建一个线程对象
2. **就绪**: 调用线程的`start()`方法,等待获取CPU的使用权
3. **运行**: 执行程序
4. **阻塞**
   1. **等待阻塞**: 调用了程序的`wait()` 方法,线程释放占用的资源,在等待池中,等待其他线程调佣`notify()`和`notifyAll()`方法后才被唤醒
   2. **同步阻塞**:线程在拿到同步锁的时候,同步锁被其他线程占用,线程进入锁池等待
   3. **其他阻塞**:线程执行了`sleep()`或`join()`方法,或者是I/O请求,当执行时间到了,就会让线程进入就绪状态.
5. **死亡**: 线程执行完毕,或者发生异常



## 21. wait(),sleep(),join(),yield()

**sleep()**和**wait()**的区别?

1. **sleep()**是**Thread**类中的静态方法,而**wait()**是**Object**中的方法
2. sleep不依赖于**synchornized**,而wait()依赖
3. **sleep**不会释放锁,而**wait()**会释放锁



**yield()**是释放锁之后是就绪状态,这就表示线程依然可以抢到**CPU**资源

**join()**执行之后,如果A调用B的**join**方法,那么**A线程阻塞**,直到**B线程结束或者中断**,**A线程才可以运行**





## 22. 看待线程安全问题

**线程安全**是指多个线程访问同一个对象的时候,都可以得到一个正确的结果,就是和单线程访问的时候可以得到同样的结果

jvm的栈就是线程安全的,每个线程拥有一块独立的栈内存

而jvm里面的堆就是线程不安全的,因为堆内存是线程共有的



## 23. Thread和Runable



## 24. 守护线程

**守护线程**就是**为非守护线程提供服务**的线程

守护线程不会守护单独的一个线程,他会**守护JVM中的所有非守护线程**,如果所有的非守护线程都运行完成之后,守护线程会**自动的结束**,不会受到自己的控制.

**GC垃圾回收机制**就是一个很典型的**守护线程**,当所有的线程都停止之后,就不会产生垃圾了,那么GC也就不用再次使用了,同是守护线程中创建的所有线程同样是守护线程



## 25. ThreadLocal的使用场景和原理

每一个**Thread**线程都有一个**ThreadLocalMap**类型的对象: **ThreadLocals**, 这里的entry存储的**key**为**ThreadLocal**对象,**value**存储的是用户自定义存储的值,同时**entry**是继承一个**弱引用**的一个类,因此如果没有强引用引用此对象,那么就会被垃圾回收

当用户使用**set()**函数的时候,**ThreadLocal**会想获取当前的线程对象,然后获取线程的**ThreadLocalMap**,然后通过**ThreadLocal**作为**Key**,自定义对象作为**value进行**存储,**get()**同理,每一个线程都有一个**ThreadLocalMap**,容器互不影响,所以没有线程安全问题

**使用场景:**

1. 在**不同层**之间进行**传值**,如果传递用户信息
2. **保存事务信息**
3. 进行**sql连接**,Session**会话管理**
4. **线程间数据隔离**

> [!Tip]
>
> Spring的jdbc connection就是通过ThreadLocal实现事务之间的隔离



## 26. ThreadLocal的内存泄漏问题

**内存泄漏**是该对象不会被使用,但是对象的内存却无法被回收

**产生原因**:

因为**ThreadLocalMap**的**entry**中的**key:ThreadLocal**是真正的弱引用对象,而**entry**实际上是强引用

但没有强引用引用**ThreadLocal**的时候



## 27. 并发,并行和串行

**串行:** 一个任务执行完成之后才能执行下一个任务,没有执行完成就不能执行下一个任务

**并行:** 同一个时间内,多个任务共同执行,相当于一条高速公路

**并发:** 同一个时间间隔内,多个任务交替进行



## 28. 并发的三大特性

**原子性,有序性,可见性**

**原子性:** 当一条或者多条指令作为操作执行的之后,要么全部执行完毕,要么都不执行

**有序性:** 指令运行过程中可能会发生**指令重排序**的问题,要保证指令不发生重排序,按照一定顺序执行

**可见性**: 要求在一个线程执行过程中要能够看到其他指令对一个共享变量的修改

> [!Tip]
>
> **volatile关键字**可以保证有序性和可见性





## 29. 为什么使用线程池,线程池的相关参数

**使用线程池的好处:**

1. 降低资源消耗, 防止反复创建和销毁线程消耗资源
2. 提高反应时间, 任务进来不用创建线程,直接使用现有线程
3. 提高线程可管理性, 将线程交给线程池管理



**线程池的参数:** 

- **corePoolSize**  --核心线程的数量

  核心活动线程,核心线程创建后并不会被销毁

- **maxinumPoolSize** --最大线程数量

  一般的活动线程为**corePoolSize**, 当出现峰值的时候,就会启用最大线程的数量

- **keepAliveTime unit** --除核心线程之外的空闲线程的存活时间

  核心线程不会被销毁,但是非核心线程到时间后会被销毁

- **workQueue**: --任务队列

  表示一个任务队列,比如核心线程数量为5, 最大线程数量为10, 队列可以存放10个任务那么如果进入10个任务,那么其中五个任务是在核心线程执行,另外5个任务是放在任务队列中,如果再进入6个任务,那么其中5个任务仍然在任务队列中,而现在会创建一个线程,并从任务队列中拿一个任务给线程

- **ThreadFactory** --线程工厂

  用来创建线程来执行任务,可以使用默认的线程工厂,创造的线程不是守护线程,同时具有相同的优先级,同时也可以使用自定义默认工厂

- **Handler** --任务拒绝策略

  一种是调用`shutdown()`函数关闭线程池,再提交任务会被拒绝,另一种是达到最大线程数量,没有能力执行任务会被拒绝





## 30. 线程池执行流程

![image-20220806144132245](https://s2.loli.net/2022/08/06/bWfsz1Zvc7LAqDr.png)![image-20220806144258083](https://s2.loli.net/2022/08/06/Q4RubYN9OXlxkmz.png)





## 31. 线程池中阻塞队列的作用,为什么先将任务加入队列,而不是直接创建线程

线程池中阻塞队列的**作用**: 

1. 因为线程池中的核心线程不会被销毁,所以使用阻塞队列来阻塞核心线程,让其不占用**CPU**的资源
2. 同时使用阻塞队列,如果阻塞队列满了,在进入任务的话,会保存当前的任务

为什么先加入队列:

​	因为创建和销毁线程会占用资源,同时只用核心线程不会被销毁,所以加入队列中是最优的



## 32. 线程池中的线程复用原理

线程池是将线程和任务解耦,同时在线程池内部,相当于一个"循环任务"在循环任务中判断线程中是否有任务,如果有任务,就调用线程的`run()`方法,



## 33. Spring是什么

**Spring**是**轻量级**的**java EE**的开源框架,是为了**简化企业复杂的业务环境**,同时**Spring**是一个**分层架构**,允许用户自己选择组件,同时也是一个**容器框架,**用来装**javaBean**,**Spring**的核心是IOC和AOP

![image-20220806165104403](https://s2.loli.net/2022/08/06/sWlr79xv26PpagS.png)



## 34. 对AOP的理解

**AOP**就是面向切面编程,在传统的**oop**上面,通常我们一个功能模块不只是只有核心功能,还有比如日志,异常处理等功能,如果在这么多代码上都加入重复的代码,就会造成代码的冗余,而使用**AOP**就将这些功能进行封装成一个切面,并且注入到业务代码中



## 35. 对IOC的理解

